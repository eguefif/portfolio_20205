gh:[github link]

# GameBoy Emulator

This is a GameBoy emulator written in Rust that accurately emulates the classic Nintendo Game Boy hardware. The emulator can run original GameBoy ROMs and successfully plays games like Tetris with proper graphics and input handling.

The emulator implements the core components of the GameBoy architecture: the Sharp LR35902 CPU (a modified Z80), the Picture Processing Unit (PPU) for graphics rendering, memory management including cartridge ROM and RAM, and input handling. Written entirely in Rust, it leverages the language's memory safety features while maintaining the performance necessary for real-time emulation.

## Goals

I created this project to learn three skills:
* Rust programming fundamentals including ownership, borrowing, and the type system
* Computer architecture and low-level programming concepts through hardware emulation
* Game console internals and how CPU instructions translate to visual output

## Spotlights

I am particularly proud of getting Tetris to run fully playable. Achieving this milestone required implementing accurate CPU instruction execution, proper timing cycles, correct PPU behavior for tile-based graphics, and synchronized screen refresh rates. Seeing the iconic Tetris pieces fall smoothly on the screen for the first time was incredibly rewarding and confirmed that all the core systems were working together correctly.

## Lessons Learned

This project was my introduction to Rust, and it taught me the language's core concepts through practical application. The borrow checker and ownership system, while initially challenging, proved invaluable for managing the emulator's complex state. I learned to think differently about memory management and appreciate Rust's guarantees about safety without garbage collection.

I gained deep insights into computer architecture that I had only understood theoretically before. Implementing CPU instructions one by one, managing memory-mapped I/O, and synchronizing different hardware components gave me a concrete understanding of how computers work at the lowest level. This knowledge has made me a better programmer overall, as I now better understand what happens beneath higher-level abstractions.

The debugging process was particularly educational. Tracking down why certain graphics weren't rendering correctly or why timing was off required methodical testing and comparison against hardware specifications. I learned to use logging effectively, write test ROMs, and verify behavior against documented CPU cycles. This systematic approach to debugging complex systems is a skill I continue to use in all my projects.
